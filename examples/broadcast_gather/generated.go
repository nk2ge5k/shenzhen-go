// Package broadcast_gather was automatically generated by Shenzhen Go.
package broadcast_gather // import "shenzhen-go/examples/broadcast_gather"

import (
	"fmt"
	"runtime"
	"sync"
)

var _ = runtime.Compiler

func Broadcast(input <-chan int, output0 chan<- int, output1 chan<- int, output2 chan<- int, output3 chan<- int) {
	// Broadcast

	defer func() {
		close(output0)
		close(output1)

	}()
	for in := range input {
		output0 <- in
		output1 <- in
	}
}

func Gather(input0 <-chan int, input1 <-chan int, input2 <-chan int, output chan<- int) {
	// Gather

	defer func() {
		close(output)
	}()
	for {
		if true && input1 == nil && input2 == nil {
			break
		}
		select {
		case in, open := <-input1:
			if !open {
				input1 = nil
				break
			}
			output <- in
		case in, open := <-input2:
			if !open {
				input2 = nil
				break
			}
			output <- in
		}
	}

}

func Print_every_input(inputs <-chan int, outputs chan<- interface{}) {
	// Print every input

	defer func() {
		if outputs != nil {
			close(outputs)
		}
	}()
	for input := range inputs {
		func() {
			fmt.Println(input)
		}()
	}
}

func Send_42_once_and_close(output chan<- int) {
	// Send 42 once and close

	output <- 42
	close(output)
}

// Run executes all the goroutines associated with the graph that generated
// this package, and waits for any that were marked as "wait for this to
// finish" to finish before returning.
func Run() {

	channel0 := make(chan int, 0)
	channel2 := make(chan int, 0)
	channel3 := make(chan int, 0)
	channel4 := make(chan int, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		Broadcast(channel2, channel0, channel4, nil, nil)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Gather(nil, channel0, channel4, channel3)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Print_every_input(channel3, nil)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Send_42_once_and_close(channel2)
		wg.Done()
	}()

	// Wait for the various goroutines to finish.
	wg.Wait()
}
